import JSZip from 'jszip';
import * as THREE from 'three';

// Box hash type to track duplicate boxes
interface BoxHash {
  [key: string]: {
    count: number;
    dimensions: {
      width: number;
      height: number;
      depth: number;
    };
    object: THREE.Object3D;
  };
}

// Create a hash key for a box based on its dimensions
export function createBoxHashKey(width: number, height: number, depth: number, borderRadius: number = 0): string {
  // Sort dimensions to ensure boxes with the same dimensions but different orientations are recognized as identical
  const dimensions = [width, height, depth].sort((a, b) => a - b);
  return `${dimensions[0]}_${dimensions[1]}_${dimensions[2]}_r${borderRadius}`;
}

// Hash boxes to identify duplicates
export function hashBoxes(boxes: THREE.Object3D[]): BoxHash {
  const boxHashes: BoxHash = {};
  
  boxes.forEach((box, index) => {
    if (box.userData && box.userData.dimensions) {
      const dims = box.userData.dimensions;
      const borderRadius = box.userData.borderRadius || 0;
      
      // Create a unique hash for this box's dimensions
      const hashKey = createBoxHashKey(
        dims.width, 
        dims.height, 
        dims.depth,
        borderRadius
      );
      
      // If we've seen this box before, increment the count
      if (boxHashes[hashKey]) {
        boxHashes[hashKey].count++;
      } else {
        // First time seeing this box, add it to our hash
        boxHashes[hashKey] = {
          count: 1,
          dimensions: dims,
          object: box
        };
      }
    }
  });
  
  return boxHashes;
}

// Generate a manifest text file listing all unique boxes and their counts
export function generateManifest(boxHashes: BoxHash): string {
  // Calculate total volume and material estimates
  let totalBoxes = 0;
  let totalVolume = 0;
  let totalPrintTime = 0;
  
  // First pass to calculate totals
  Object.values(boxHashes).forEach(data => {
    const {count, dimensions} = data;
    totalBoxes += count;
    
    // Calculate approximate volume of plastic used (in cm³)
    // This is just a rough estimate based on the box dimensions and wall thickness
    const boxVolume = (dimensions.width * dimensions.height * dimensions.depth) / 1000; // mm³ to cm³
    totalVolume += boxVolume * count;
    
    // Very rough print time estimate (minutes) - just for reference
    // Based on simple heuristic of ~5 minutes per cm³ at medium quality
    const estimatedTime = boxVolume * 5;
    totalPrintTime += estimatedTime * count;
  });
  
  // Format the manifest
  let manifest = 'PrintBox Export Manifest\n';
  manifest += '===========================\n\n';
  manifest += `Date: ${new Date().toLocaleDateString()}\n`;
  manifest += `Unique Box Designs: ${Object.keys(boxHashes).length}\n`;
  manifest += `Total Boxes to Print: ${totalBoxes}\n`;
  manifest += `Estimated Material Volume: ${totalVolume.toFixed(2)} cm³\n`;
  manifest += `Estimated Print Time: ${(totalPrintTime / 60).toFixed(1)} hours\n\n`;
  manifest += 'Print Queue:\n';
  manifest += '-----------------------------\n\n';
  
  // Sort boxes by count (highest quantity first)
  const sortedBoxes = Object.entries(boxHashes).sort((a, b) => {
    return b[1].count - a[1].count;
  });
  
  sortedBoxes.forEach(([hashKey, data], index) => {
    const {count, dimensions} = data;
    const filename = `box_${dimensions.width}x${dimensions.height}x${dimensions.depth}_mm.stl`;
    const volume = (dimensions.width * dimensions.height * dimensions.depth) / 1000; // mm³ to cm³
    
    manifest += `${index + 1}. ${filename}\n`;
    manifest += `   Dimensions: ${dimensions.width} × ${dimensions.height} × ${dimensions.depth} mm\n`;
    manifest += `   Quantity: ${count}\n`;
    manifest += `   Volume per piece: ${volume.toFixed(2)} cm³\n`;
    manifest += `   Total volume: ${(volume * count).toFixed(2)} cm³\n`;
    manifest += `\n`;
  });
  
  manifest += '\nNotes:\n';
  manifest += '- Volume and print time estimates are approximate and will vary based on your printer settings\n';
  manifest += '- Print times are based on medium quality settings\n';
  manifest += '- For hollow boxes, actual material usage will be lower than the volume estimate\n';
  manifest += '\nGenerated by PrintBox - https://printbox.app';
  
  return manifest;
}

// Create a zip file containing all unique STL files and a manifest
export async function createBoxExportZip(
  boxHashes: BoxHash, 
  stlDataGetter: (box: THREE.Object3D) => Uint8Array | string
): Promise<Blob> {
  const zip = new JSZip();
  
  // Add each unique box as an STL file
  Object.entries(boxHashes).forEach(([hashKey, data]) => {
    const {dimensions, object} = data;
    const filename = `box_${dimensions.width}x${dimensions.height}x${dimensions.depth}_mm.stl`;
    
    // Get the STL data for this box
    const stlData = stlDataGetter(object);
    
    // Add to zip
    zip.file(filename, stlData);
  });
  
  // Add manifest file
  const manifest = generateManifest(boxHashes);
  zip.file('manifest.txt', manifest);
  
  // Generate zip file
  return await zip.generateAsync({type: 'blob'});
}

// Download a zip file with a specified name
export function downloadZip(zipBlob: Blob, zipFilename: string = 'printbox_export.zip'): void {
  const link = document.createElement('a');
  link.href = URL.createObjectURL(zipBlob);
  link.download = zipFilename;
  link.click();
  
  // Clean up the URL object after the download starts
  setTimeout(() => {
    URL.revokeObjectURL(link.href);
  }, 100);
}
